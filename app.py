# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S-q2wfBvKOF-EDxyRmeWZd4Rjq5Vkpxc
"""

# Install streamlit if it's not already installed
#!pip install streamlit

import os
import joblib
import numpy as np
import pandas as pd
import streamlit as st

from sklearn.metrics import (
    accuracy_score,
    roc_auc_score,
    precision_score,
    recall_score,
    f1_score,
    matthews_corrcoef,
    confusion_matrix,
    classification_report
)

# SETTINGS
st.set_page_config(page_title="Credit Default - Model Comparison", layout="wide")

TARGET_COL = "default payment next month"

MODEL_FILES = {
    "Logistic Regression": "model/logistic_regression.pkl",
    "Decision Tree": "model/decision_tree.pkl",
    "kNN": "model/knn.pkl",
    "Naive Bayes": "model/naive_bayes.pkl",
    "Random Forest": "model/random_forest.pkl",
    "XGBoost": "model/xgboost.pkl",
}

# HELPERS
def safe_predict_proba(model, X):
    """
    Most classifiers support predict_proba.
    This fallback handles rare cases safely.
    """
    if hasattr(model, "predict_proba"):
        return model.predict_proba(X)[:, 1]
    if hasattr(model, "decision_function"):
        s = model.decision_function(X)
        return (s - s.min()) / (s.max() - s.min() + 1e-9)
    raise ValueError("Selected model does not support probability prediction.")

def compute_metrics(y_true, y_pred, y_prob):
    return {
        "Accuracy": float(accuracy_score(y_true, y_pred)),
        "AUC": float(roc_auc_score(y_true, y_prob)),
        "Precision": float(precision_score(y_true, y_pred, zero_division=0)),
        "Recall": float(recall_score(y_true, y_pred, zero_division=0)),
        "F1 Score": float(f1_score(y_true, y_pred, zero_division=0)),
        "MCC": float(matthews_corrcoef(y_true, y_pred)),
    }

def load_dataframe(uploaded_file):
    """
    Reads CSV and does minimal cleanup. Keeps it simple for assignment.
    """
    df = pd.read_csv(uploaded_file)
    df.columns = [str(c).strip() for c in df.columns]
    df = df.dropna().reset_index(drop=True)
    return df

# -----------------------------
# UI
# -----------------------------
st.title("Credit Card Default Prediction ‚Äî Streamlit App")
st.write(
    "Upload a **test CSV** (small file recommended), select a model, and view evaluation metrics.\n\n"
    "**Required features covered:** CSV upload, model dropdown, metrics, confusion matrix / classification report."
)

col_left, col_right = st.columns([1, 1])

with col_left:
    model_name = st.selectbox("Select a Model", list(MODEL_FILES.keys()))
with col_right:
    show_preview = st.checkbox("Show uploaded data preview", value=True)

uploaded = st.file_uploader("Upload Test CSV", type=["csv"])

st.info(
    f"Your uploaded CSV must include the target column: `{TARGET_COL}`.\n"
    "All other feature columns should match the dataset format."
)

# Add download button for sample test data
st.markdown("### üì• Download Sample Test Data")
st.write("Don't have test data? Download our sample test CSV file:")

try:
    # Load the sample test data
    sample_test_path = "data/test.csv"
    if os.path.exists(sample_test_path):
        with open(sample_test_path, "rb") as file:
            st.download_button(
                label="‚¨áÔ∏è Download Sample Test CSV",
                data=file,
                file_name="test.csv",
                mime="text/csv",
                help="Download a sample test dataset to try out the app"
            )
    else:
        st.warning(f"Sample test file not found at: {sample_test_path}")
except Exception as e:
    st.warning(f"Could not load sample test file: {e}")

if uploaded is None:
    st.stop()

# -----------------------------
# LOAD MODEL
# -----------------------------
model_path = MODEL_FILES[model_name]
if not os.path.exists(model_path):
    st.error(
        f"Model file not found: `{model_path}`.\n\n"
        "Train and save models first using `python train_models.py`."
    )
    st.stop()

try:
    model = joblib.load(model_path)
except Exception as e:
    st.error(f"Could not load model file. Error: {e}")
    st.stop()

# -----------------------------
# LOAD DATA AND PREDICT + EVALUATE
# -----------------------------

# Initialize df to None
df = None

# Load the uploaded CSV data
try:
    df = load_dataframe(uploaded)
    if show_preview:
        st.subheader("Uploaded Data Preview")
        st.dataframe(df)
except Exception as e:
    st.error(f"Could not load uploaded CSV. Error: {e}")
    st.stop()

# Only proceed if a dataframe was successfully loaded
if df is not None:
    # Separate features (X) and target (y_true)
    if TARGET_COL not in df.columns:
        st.error(f"Uploaded CSV must contain the target column: '{TARGET_COL}'.")
        st.stop()

    y_true = df[TARGET_COL]
    X = df.drop(columns=[TARGET_COL])

    try:
        y_pred = model.predict(X)
        y_prob = safe_predict_proba(model, X)
    except Exception as e:
        st.error(
            "Prediction failed. This usually happens if the uploaded CSV columns do not match.\n\n"
            f"Error: {e}"
        )
        st.stop()

    metrics = compute_metrics(y_true, y_pred, y_prob)
    cm = confusion_matrix(y_true, y_pred)
    report = classification_report(y_true, y_pred, digits=4)
else:
    st.info("No file uploaded. Please upload a CSV to proceed.")
    # In Colab, st.stop() doesn't stop the cell, so we can't use return here.
    # In a real Streamlit app, st.stop() would suffice.

# -----------------------------
# DISPLAY RESULTS
# -----------------------------

# Only display results if a dataframe was successfully loaded and metrics were computed
if 'metrics' in locals():
    st.subheader(f"Results for: {model_name}")

    m1, m2 = st.columns([1, 1])

    with m1:
        st.markdown("### Evaluation Metrics")
        st.dataframe(pd.DataFrame([metrics]))

    with m2:
        st.markdown("### Confusion Matrix")
        cm_df = pd.DataFrame(
            cm,
            index=["Actual 0", "Actual 1"],
            columns=["Pred 0", "Pred 1"]
        )
        st.dataframe(cm_df)

    st.markdown("### Classification Report")
    st.code(report, language="text")
else:
    st.info("Upload a CSV and select a model to see evaluation results.")

